/// Python configparser module - Configuration file parser
const std = @import("std");
const ast = @import("ast");
const CodegenError = @import("main.zig").CodegenError;
const NativeCodegen = @import("main.zig").NativeCodegen;

/// Generate configparser.ConfigParser() -> ConfigParser object
pub fn genConfigParser(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    _ = args;
    try self.emit("struct {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("sections_map: hashmap_helper.StringHashMap(hashmap_helper.StringHashMap([]const u8)),\n");
    try self.emitIndent();
    try self.emit("pub fn init() @This() {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("return @This(){\n");
    self.indent();
    try self.emitIndent();
    try self.emit(".sections_map = hashmap_helper.StringHashMap(hashmap_helper.StringHashMap([]const u8)).init(__global_allocator),\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("};\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn read(self: *@This(), filename: []const u8) !void {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("const file = std.fs.cwd().openFile(filename, .{}) catch return;\n");
    try self.emitIndent();
    try self.emit("defer file.close();\n");
    try self.emitIndent();
    try self.emit("const content = file.readToEndAlloc(allocator, 1024 * 1024) catch return;\n");
    try self.emitIndent();
    try self.emit("var current_section: ?[]const u8 = null;\n");
    try self.emitIndent();
    try self.emit("var lines = std.mem.splitScalar(u8, content, '\\n');\n");
    try self.emitIndent();
    try self.emit("while (lines.next()) |line| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n");
    try self.emitIndent();
    try self.emit("if (trimmed.len == 0 or trimmed[0] == '#' or trimmed[0] == ';') continue;\n");
    try self.emitIndent();
    try self.emit("if (trimmed[0] == '[' and trimmed[trimmed.len - 1] == ']') {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("current_section = trimmed[1 .. trimmed.len - 1];\n");
    try self.emitIndent();
    try self.emit("if (self.sections_map.get(current_section.?) == null) {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("self.sections_map.put(current_section.?, hashmap_helper.StringHashMap([]const u8).init(__global_allocator)) catch continue;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("} else if (current_section != null) {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (std.mem.indexOfScalar(u8, trimmed, '=')) |eq_pos| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("const key = std.mem.trim(u8, trimmed[0..eq_pos], \" \\t\");\n");
    try self.emitIndent();
    try self.emit("const value = std.mem.trim(u8, trimmed[eq_pos + 1 ..], \" \\t\");\n");
    try self.emitIndent();
    try self.emit("if (self.sections_map.getPtr(current_section.?)) |sec| sec.put(key, value) catch {};\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn read_string(self: *@This(), content: []const u8) void {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("var current_section: ?[]const u8 = null;\n");
    try self.emitIndent();
    try self.emit("var lines = std.mem.splitScalar(u8, content, '\\n');\n");
    try self.emitIndent();
    try self.emit("while (lines.next()) |line| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("const trimmed = std.mem.trim(u8, line, \" \\t\\r\");\n");
    try self.emitIndent();
    try self.emit("if (trimmed.len == 0 or trimmed[0] == '#' or trimmed[0] == ';') continue;\n");
    try self.emitIndent();
    try self.emit("if (trimmed[0] == '[' and trimmed[trimmed.len - 1] == ']') {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("current_section = trimmed[1 .. trimmed.len - 1];\n");
    try self.emitIndent();
    try self.emit("if (self.sections_map.get(current_section.?) == null) {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("self.sections_map.put(current_section.?, hashmap_helper.StringHashMap([]const u8).init(__global_allocator)) catch continue;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("} else if (current_section != null) {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (std.mem.indexOfScalar(u8, trimmed, '=')) |eq_pos| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("const key = std.mem.trim(u8, trimmed[0..eq_pos], \" \\t\");\n");
    try self.emitIndent();
    try self.emit("const value = std.mem.trim(u8, trimmed[eq_pos + 1 ..], \" \\t\");\n");
    try self.emitIndent();
    try self.emit("if (self.sections_map.getPtr(current_section.?)) |sec| sec.put(key, value) catch {};\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn sections(self: *@This()) [][]const u8 {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("var result = std.ArrayList([]const u8).init(__global_allocator);\n");
    try self.emitIndent();
    try self.emit("var iter = self.sections_map.keyIterator();\n");
    try self.emitIndent();
    try self.emit("while (iter.next()) |key| result.append(allocator, key.*) catch continue;\n");
    try self.emitIndent();
    try self.emit("return result.items;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn has_section(self: *@This(), section: []const u8) bool {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("return self.sections_map.get(section) != null;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn get(self: *@This(), section: []const u8, option: []const u8) ?[]const u8 {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.sections_map.get(section)) |sec| return sec.get(option);\n");
    try self.emitIndent();
    try self.emit("return null;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn getint(self: *@This(), section: []const u8, option: []const u8) ?i64 {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.get(section, option)) |val| return std.fmt.parseInt(i64, val, 10) catch null;\n");
    try self.emitIndent();
    try self.emit("return null;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn getfloat(self: *@This(), section: []const u8, option: []const u8) ?f64 {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.get(section, option)) |val| return std.fmt.parseFloat(f64, val) catch null;\n");
    try self.emitIndent();
    try self.emit("return null;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn getboolean(self: *@This(), section: []const u8, option: []const u8) ?bool {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.get(section, option)) |val| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (std.mem.eql(u8, val, \"true\") or std.mem.eql(u8, val, \"yes\") or std.mem.eql(u8, val, \"1\")) return true;\n");
    try self.emitIndent();
    try self.emit("if (std.mem.eql(u8, val, \"false\") or std.mem.eql(u8, val, \"no\") or std.mem.eql(u8, val, \"0\")) return false;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("return null;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn set(self: *@This(), section: []const u8, option: []const u8, value: []const u8) void {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.sections_map.getPtr(section)) |sec| sec.put(option, value) catch {};\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn add_section(self: *@This(), section: []const u8) void {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("if (self.sections_map.get(section) == null) {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("self.sections_map.put(section, hashmap_helper.StringHashMap([]const u8).init(__global_allocator)) catch {};\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("pub fn options(self: *@This(), section: []const u8) [][]const u8 {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("var result = std.ArrayList([]const u8).init(__global_allocator);\n");
    try self.emitIndent();
    try self.emit("if (self.sections_map.get(section)) |sec| {\n");
    self.indent();
    try self.emitIndent();
    try self.emit("var iter = sec.keyIterator();\n");
    try self.emitIndent();
    try self.emit("while (iter.next()) |key| result.append(allocator, key.*) catch continue;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    try self.emitIndent();
    try self.emit("return result.items;\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}\n");
    self.dedent();
    try self.emitIndent();
    try self.emit("}.init()");
}

/// Generate configparser.RawConfigParser() -> RawConfigParser (same as ConfigParser for now)
pub fn genRawConfigParser(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    try genConfigParser(self, args);
}

/// Generate configparser.SafeConfigParser() -> SafeConfigParser (deprecated alias)
pub fn genSafeConfigParser(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    try genConfigParser(self, args);
}
