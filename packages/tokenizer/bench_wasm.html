<!DOCTYPE html>
<html>
<head>
    <title>Tokenizer WASM Benchmark</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }
        h1 { color: #4ec9b0; }
        table { border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #3e3e42; padding: 12px; text-align: left; }
        th { background: #252526; }
        .winner { background: #1e3a20; font-weight: bold; }
        button { padding: 10px 20px; font-size: 16px; margin: 10px 0; background: #0e639c; color: white; border: none; cursor: pointer; }
        button:hover { background: #1177bb; }
        .loading { color: #4ec9b0; }
        .error { color: #f48771; }
    </style>
</head>
<body>
    <h1>üèÜ Tokenizer WASM Benchmark</h1>
    <p>Testing: PyAOT (Zig‚ÜíWASM), tiktoken (Rust‚ÜíWASM), gpt-tokenizer (JS), ai-tokenizer</p>

    <button onclick="runBenchmark()">Run Benchmark (10K iterations)</button>

    <div id="status"></div>
    <div id="results"></div>

    <script type="module">
        const TEXT = "The cat sat on the mat. The dog ran in the park. The bird flew in the sky. The fish swam in the sea. The snake slithered on the ground. The rabbit hopped in the field. The fox ran through the forest. The bear climbed the tree. The wolf howled at the moon. The deer grazed in the meadow.";
        const ITERATIONS = 10000;

        let pyaotModule = null;

        async function loadPyAOTWASM() {
            const response = await fetch('zig-out/bin/tokenizer.wasm');
            const bytes = await response.arrayBuffer();
            const {instance} = await WebAssembly.instantiate(bytes, {});

            // Load tokenizer JSON
            const tokenizerJSON = await fetch('cl100k_base.json').then(r => r.text());

            // Allocate memory for JSON string
            const jsonBytes = new TextEncoder().encode(tokenizerJSON);
            const jsonPtr = instance.exports.alloc(jsonBytes.length);
            const memory = new Uint8Array(instance.exports.memory.buffer);
            memory.set(jsonBytes, jsonPtr);

            // Initialize tokenizer
            const initResult = instance.exports.initFromData(jsonPtr, jsonBytes.length);
            instance.exports.dealloc(jsonPtr, jsonBytes.length);

            if (!initResult) throw new Error('Failed to initialize tokenizer');

            return {
                encode(text) {
                    const textBytes = new TextEncoder().encode(text);
                    const textPtr = instance.exports.alloc(textBytes.length);
                    memory.set(textBytes, textPtr);

                    const outLenPtr = instance.exports.alloc(4);
                    const tokensPtr = instance.exports.encode(textPtr, textBytes.length, outLenPtr);

                    const outLenView = new Uint32Array(instance.exports.memory.buffer, outLenPtr, 1);
                    const tokensLen = outLenView[0];

                    const tokens = new Uint32Array(instance.exports.memory.buffer, tokensPtr, tokensLen);
                    const result = Array.from(tokens);

                    instance.exports.free_tokens(tokensPtr, tokensLen);
                    instance.exports.dealloc(textPtr, textBytes.length);
                    instance.exports.dealloc(outLenPtr, 4);

                    return result;
                }
            };
        }

        window.runBenchmark = async function() {
            const results = [];
            const statusDiv = document.getElementById('status');
            const resultsDiv = document.getElementById('results');

            statusDiv.innerHTML = '<p class="loading">Running benchmarks...</p>';
            resultsDiv.innerHTML = '';

            // Test 1: PyAOT (Zig ‚Üí WASM)
            try {
                statusDiv.innerHTML += '<p>Testing PyAOT (Zig ‚Üí WASM)...</p>';

                pyaotModule = await loadPyAOTWASM();

                // Warmup
                for (let i = 0; i < 100; i++) pyaotModule.encode(TEXT);

                // Benchmark
                const start = performance.now();
                for (let i = 0; i < ITERATIONS; i++) {
                    pyaotModule.encode(TEXT);
                }
                const elapsed = performance.now() - start;

                const tokens = pyaotModule.encode(TEXT);
                results.push({
                    name: 'PyAOT (Zig‚ÜíWASM)',
                    time: Math.round(elapsed),
                    tokens: tokens.length,
                    type: 'WASM',
                    size: '60KB'
                });
            } catch (e) {
                results.push({ name: 'PyAOT', error: e.message });
            }

            // Test 2: gpt-tokenizer (Pure JS)
            try {
                statusDiv.innerHTML += '<p>Testing gpt-tokenizer (Pure JS)...</p>';

                const { encode } = await import('https://cdn.jsdelivr.net/npm/gpt-tokenizer@2.1.1/+esm');

                // Warmup
                for (let i = 0; i < 100; i++) encode(TEXT);

                // Benchmark
                const start = performance.now();
                for (let i = 0; i < ITERATIONS; i++) encode(TEXT);
                const elapsed = performance.now() - start;

                results.push({
                    name: 'gpt-tokenizer',
                    time: Math.round(elapsed),
                    tokens: encode(TEXT).length,
                    type: 'Pure JS',
                    size: '~200KB'
                });
            } catch (e) {
                results.push({ name: 'gpt-tokenizer', error: e.message });
            }

            // Test 3: tiktoken WASM (if available locally)
            try {
                statusDiv.innerHTML += '<p>Testing tiktoken (Rust‚ÜíWASM)...</p>';

                const tiktoken = await import('./node_modules/@dqbd/tiktoken/lite/init.js');
                const model = await tiktoken.getEncoding('cl100k_base');

                // Warmup
                for (let i = 0; i < 100; i++) model.encode(TEXT);

                // Benchmark
                const start = performance.now();
                for (let i = 0; i < ITERATIONS; i++) model.encode(TEXT);
                const elapsed = performance.now() - start;

                results.push({
                    name: 'tiktoken (Rust‚ÜíWASM)',
                    time: Math.round(elapsed),
                    tokens: model.encode(TEXT).length,
                    type: 'WASM',
                    size: '~400KB'
                });
                model.free();
            } catch (e) {
                results.push({ name: 'tiktoken', error: 'Not available locally' });
            }

            // Display results
            displayResults(results);
            statusDiv.innerHTML = '<p class="loading">‚úÖ Complete!</p>';
        };

        function displayResults(results) {
            const successful = results.filter(r => !r.error).sort((a, b) => a.time - b.time);
            const fastest = successful[0]?.time || 1;

            let html = `
                <h2>Results (${ITERATIONS} iterations, 286-byte text)</h2>
                <table>
                    <tr>
                        <th>Implementation</th>
                        <th>Time</th>
                        <th>vs Fastest</th>
                        <th>Size</th>
                        <th>Tokens</th>
                        <th>Type</th>
                    </tr>
            `;

            successful.forEach((r, i) => {
                const speedup = (r.time / fastest).toFixed(2);
                const rowClass = i === 0 ? 'winner' : '';
                const trophy = i === 0 ? ' üèÜ' : '';
                html += `
                    <tr class="${rowClass}">
                        <td>${r.name}${trophy}</td>
                        <td>${r.time}ms</td>
                        <td>${speedup}x</td>
                        <td>${r.size || 'N/A'}</td>
                        <td>${r.tokens}</td>
                        <td>${r.type}</td>
                    </tr>
                `;
            });

            // Show errors
            const errors = results.filter(r => r.error);
            errors.forEach(r => {
                html += `
                    <tr>
                        <td>${r.name}</td>
                        <td colspan="5" class="error">Error: ${r.error}</td>
                    </tr>
                `;
            });

            html += '</table>';

            html += `
                <h3>Comparison with Native (60K iterations):</h3>
                <ul>
                    <li>PyAOT (Zig native): 741ms üèÜ</li>
                    <li>TokenDagger (C): 775ms</li>
                    <li>tiktoken (Rust): 1194ms</li>
                </ul>
            `;

            document.getElementById('results').innerHTML = html;
        }
    </script>
</body>
</html>
